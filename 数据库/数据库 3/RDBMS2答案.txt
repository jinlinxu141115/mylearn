数据库第一周测试(及格的都是勇士)
第一有额外小零食
不许看ppt, 不许翻笔记, 不许讨论
可以使用终端

简答题(1题3分) 总分72分
1. MySQL主从同步工作原理,(提示:主从中一共3个线程是做什么的)?
主库开启binlog日志, 主库有一个I/O线程, 名字叫binlog.dump. 从库I/O线程对主库发起同步请求, 主库把binlog日志推送给从库. 从库I/O线程接受数据并写入自己的中继日志(relay log). 从库SQL线程读取中继日志写入本库.

2. MySQL主从同步复制模式(3种), 并写出各自的特点, 哪一种是主从同步的默认模式?
异步复制( Asynchronous replication)(默认)
主库执行玩一次事务后,立即将结果返回给客户端,并不关系从库是否已经接受并处理.

全同步服务( Fully syschronous replication)
当主库执行完一次事务, 且所有从库都执行了该事务后才返回给客户端

半同步复制(Semissynchronous replication)
介于异步复制和完全同步复制之间
主库在执行完一次事务后,等待至少一个从库收到并写到relay log中才返回给客户端

3. 什么是数据库中间件? 写出3种常见的数据库中间件.
不同服务器之间负责数据传递, 服务控制或者性能监控的组件,中间件最大的特点是解耦服务, 让不同的服务之间可以采用某种规范进行交互.
数据库中间件有: mycat, maxscale, mysql-proxy

4. 如果是主从从模式, 第一个从需要添加哪个额外参数?
log_slave_updates

5. 主从同步结构,写出4种
一主一从
一主多从
主从从
互为主从

6. 数据读写分离工作原理
多台mysql服务器
分别提供读 写服务 均衡流量
通过主从复制保存数据一致性
由MySQL代理面向客户端
收到SQL写请求时,交给服务器A处理
收到SQL读请求时交给服务器B处理
具体区分策略由服务器设置

7. 读写分离的优劣是什么, 在什么场景下应用?
数据库连接池需要区分：读连接池，写连接池
如果要保证读高可用，读连接池要实现故障自动转移
有潜在的主库从库一致性问题

场景应用:
大多数互联网业务，往往读多写少，这时候，数据库的读会首先称为数据库的瓶颈，这时，如果我们希望能够线性的提升数据库的读性能，消除读写锁冲突从而提升数据库的写性能，那么就可以使用“分组架构”（读写分离架构）。用一句话概括，读写分离是用来解决数据库的读性能瓶颈的。

8. 读写分离中两个授权用户名称以及作用.
监控用户: 区分谁是主库,谁是从库
路由用户: 查看数据库访问用户是否存在

9. 数据库分库分表工作原理
当MyCat收到一个SQL查询时
先解析这个SQL查找涉及到的表
然后看此表的定义，如果有分片规则 则获取SQL里分片字段的值，并匹配分片函数，获得分片列表
然后将SQL发往这些分片去执行
最后收集和处理所有分片结果数据 并返回到客户端

10. 分库分表的优劣是什么, 在什么场景下应用?
大部分的互联网业务，数据量都非常大，单库容量最容易成为瓶颈，当单库的容量成为了瓶颈，我们希望提高数据库的写性能，降低单库容量的话，就可以采用水平切分了。

11. 什么是水平分割, 什么是垂直分割?
垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。
垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。

水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。

12. MySQL8大工作组件名称(可写英语)及作用
连接池: 检查是否有空闲的线程和是否有硬件资源分配给线程使用.
sql接口 把SQL命令传递给mysqld进程
分析器 检查执行的SQL命令是否语法错悟
优化器 优化执行的SQL命令,以最节省硬件资源的方式运行
查询缓存 存储客户端曾经查找过的sql记录
存储引擎 访问表时 决定对表加锁的粒度(表锁 行锁 页面锁)
文件系统 存储数据的存储设备(如硬盘)
管理工具 安装mysql数据库服务软件后自带的命令

13. mycat10种分片规则写出4种
枚举法
求模法
约定范围
auto_sharding_long

14. mycat种server.xml, schema.xml, rule.xml分别是配置什么的?
server.xml  配置用户,数据库
schema.xml  配置数据分片
rule.xml    配置分片规则

15. MHA工作原理
MHA 由MHA Manager(管理节点) 和 MHA Node(数据节点) 组成
MHA Manager 可以单独部署在独立服务器上 管理多个master-Slave集群 也可以部署在 一台Slave节点上, 
MHA Node 运行在每台MySQL服务器上,
MHA Manager会定时探测集群的master节点 当master出现故障时,它可以自动将最新数据的Slave提升为master,然后将其他的Slave中指向新的master,整个故障转移过程对应用程序完全透明
MHA Manager 即定时监控主库,当主库挂了之后从备用主库中竞选新的主库,并自动将所有从库的主库指向新的主库

16. 什么是锁? 锁粒度又有哪几种?
数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。
表级锁：直接对整张表加锁
行级锁：只锁定某一行
页级锁 对整个页面加锁(即对内存数据加锁)

17. 什么是事务, 特点是什么?
事务 指 从连接数据库开始到断开连接的整个过程
事务的特性 原子性 、一致性、隔离性、持久性

18. InnoDB存储引擎与MyISAM的区别(3点)
MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁；
不支持事务；
不支持外键；
不支持崩溃后的安全恢复；
在表有读取查询的同时，支持往表中插入新纪录；
支持BLOB和TEXT的前500个字符索引，支持全文索引；
支持延迟更新索引，极大提升写入性能；
对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用。

InnoDB在MySQL 5.5后成为默认索引，它的特点是：
支持行锁，采用MVCC来支持高并发；
支持事务；
支持外键；
支持崩溃后的安全恢复；
支持全文索引

19. 如何优化MySQL
调整mysql服务运行参数 并发连接数、连接超时时间、重复使用的线程数
配置mysql最大并发 
set global max_connections = 200
[mysqld]
max_connections = 200
> show global status like "%conn%";
> show global status like "max_used_connections"; ##曾经最大并发连接数
> show variables like "max_connections"; ##默认最大并发连接数
max_connections/max_connections=0.8 或 0.85
> show variables like "%timeout%";
##查看连接超时变量
##死锁 多台服务器访问同一表或行,因为锁的原因,服务器互相等待对方操作完成而出现死等对方,造成死锁.
调整与查询相关的参数 查询缓存、索引缓存
sort_buffer_size 为每个要排序的线程分配此大小的缓存空间
## 用于调高排序查询时的速度
read_buffer_size 为顺序读取表记录保存的缓存大小
## 用于调高默认排序下的查询速度
thread_cache_size 允许保存在缓存中被重复使用的线程数量
## 用于处理客户端的连接请求,默认11个线程,可以同时处理9台客户机的请求,但当客户端断开连接后不杀死这个线程,当下次客户端链接时就不用再创建线程,减轻CPU负载
table_open_cache 为所有线程缓存的打开的表的数据
## 数据库操作过程 打开文件库/表 ---->调入 内存---CPU--->写回 硬盘--->关闭
## 默认同时开启2000张表
启动慢查询日志 slow-query-log
## 配置文档启动慢查询日志，记录耗时较长或不适用索引的查询操作

20. Delete、truncate、drop都是删除语句，它们有什么分别？
1).delete 属于DML语句，删除数据，保留表结构，需要commit，可以回滚，如果数据量大，很慢。
2).truncate 属于DDL语句，删除所有数据，保留表结构，自动commit，不可以回滚，一次全部删除所有数据，速度相对较快。
3).Drop属于 DDL语句，删除数据和表结构,不需要commit，删除速度最快。


21. 忽然有一天业务数据库CPU负载到了500%, 写出你的解决思路
1 top 之后，确定是否mysqld进程占据了所有资, 如果不是kill占用资源高得进程
2 查看iostat，磁盘读写是否正常。
3 查看error日志，是否有任何异常
4 show eninge innodb status\G，查看是否有死锁信息。
5 show full processlist, 观察并发数,数据库并发不超过300以上问题不大
6 查看slow log, 是哪些语句耗时长
7 用explain判断查询语句中少了什么索引
8 抢救方法: pt-kill  --match-info "^(select|SELECT)"--busy-time 3--victim all --interval 1--kill --print --daemonize > /root/kill.txt


22. 什么是数据库视图
1 是一种虚拟存在的表
2 内容与真实的表相似,包含一系列带有名称的列和行数据
3 视图并不在数据库中以存储数据的形式存在
4 行和列的数据来自定义视图时查询所引用的基本表,并且在具体引用事务时动态生成
更新视图表的数据 及跟新基本表的数据
更新基本表的数据时 视图表数据也发生改变
优点 简单 安全 数据独立

23. 什么是MySQL存储过程
相当于MySQL语句组成的脚本
	指的是数据库中保存的一系列SQL命令的集合
	可以在存储过程中使用变量、条件判断、流程控制等
优点：
	提高性能
	可减轻网络负担
	可以防止对表的直接访问
	避免重复编写SQL操作
缺点:
	会让比较繁忙得数据变得资源更紧缺
	调试非常麻烦
	因此线上得服务器一般禁用存储过程

24. MySQL如何保证复制过程中数据一致性及减少数据同步延迟?




多表联合查询(1题3分)
http://www.zsythink.net/archives/1105
mysql> select * from t1;
+------+-------+
| t1id | t1str |
+------+-------+
|    1 | 1     |
|    2 | 2     |
|    3 | 3     |
+------+-------+

mysql> select * from t2;
+------+-------+
| t2id | t2str |
+------+-------+
|    2 | a     |
|    3 | b     |
+------+-------+

1. 同时查询两张表, 显示t1与t2的笛卡尔积.(又称之为交叉连接) 2种写法(6分)

2. 用内连接方法查询2个表, 条件为t1.t1id=t2.t2id

3. 左链接查询t1和t2表,结果粘贴

4. 右链接查询t1和t2表,结果粘贴

5. 利用嵌套查询, 查找t1表中t1id字段小于任意t2表的t2id字段的所有信息.


集群搭建(10分)
配置MHA集群(需要开启半同步复制, binlog记录格式为mixed)
0.前提准备
56可以无密码ssh 访问51-55
51-55 主机可以彼此互相无密码ssh访问
mha-soft-student拷贝给51-56
51-55 恢复为独立的数据库服务器
ip 规划
角色			ip地址			主机名
Master主节点服务器	192.168.4.51		mysql51
备用1主节点服务器	192.168.4.52		mysql52
备用2主节点服务器	192.168.4.53		mysql53
第1台slave服务器	192.168.4.54		mysql54
第2台slave服务器	192.168.4.55		mysql55
MHA_manager服务器	192.168.4.56		mysql56
VIP地址			192.168.4.100
提示:
1. 51-55安装node相关rpm包(1分)

2. 配置MySQL主从同步(一主多从)(主从配置3分, 开启半同步复制2分)

3. 配置管理主机(2分)

4. 创建故障切换脚本并把vip地址部署在51主库上(1分)

5. 测试(1分)

26.隔离级别?

事务的四种隔离级别

数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。

Read uncommitted

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。

Read committed

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…

分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

那怎么解决可能的不可重复读问题？Repeatable read ！

Repeatable read

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

什么时候会出现幻读？

事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

那怎么解决幻读问题？Serializable！

Serializable 序列化

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。

